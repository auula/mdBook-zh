<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>mdBook 中文文档</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="mdbook :) markdown生成记. 就像 Gitbook, 但专为 Rust 设计">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="README.zh.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">User Guide</li><li class="chapter-item expanded "><a href="guide/installation.zh.html"><strong aria-hidden="true">1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="guide/reading.zh.html"><strong aria-hidden="true">2.</strong> Reading Books</a></li><li class="chapter-item expanded "><a href="guide/creating.zh.html"><strong aria-hidden="true">3.</strong> Creating a Book</a></li><li class="chapter-item expanded affix "><li class="part-title">Reference Guide</li><li class="chapter-item expanded "><a href="cli/README.zh.html"><strong aria-hidden="true">4.</strong> Command Line Tool</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cli/init.zh.html"><strong aria-hidden="true">4.1.</strong> init</a></li><li class="chapter-item expanded "><a href="cli/build.zh.html"><strong aria-hidden="true">4.2.</strong> build</a></li><li class="chapter-item expanded "><a href="cli/watch.zh.html"><strong aria-hidden="true">4.3.</strong> watch</a></li><li class="chapter-item expanded "><a href="cli/serve.zh.html"><strong aria-hidden="true">4.4.</strong> serve</a></li><li class="chapter-item expanded "><a href="cli/test.zh.html"><strong aria-hidden="true">4.5.</strong> test</a></li><li class="chapter-item expanded "><a href="cli/clean.zh.html"><strong aria-hidden="true">4.6.</strong> clean</a></li><li class="chapter-item expanded "><a href="cli/completions.zh.html"><strong aria-hidden="true">4.7.</strong> completions</a></li></ol></li><li class="chapter-item expanded "><a href="format/README.zh.html"><strong aria-hidden="true">5.</strong> Format</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="format/summary.zh.html"><strong aria-hidden="true">5.1.</strong> SUMMARY.md</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.1.</strong> Draft chapter</div></li></ol></li><li class="chapter-item expanded "><a href="format/configuration/README.zh.html"><strong aria-hidden="true">5.2.</strong> Configuration</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="format/configuration/general.zh.html"><strong aria-hidden="true">5.2.1.</strong> General</a></li><li class="chapter-item expanded "><a href="format/configuration/preprocessors.zh.html"><strong aria-hidden="true">5.2.2.</strong> Preprocessors</a></li><li class="chapter-item expanded "><a href="format/configuration/renderers.zh.html"><strong aria-hidden="true">5.2.3.</strong> Renderers</a></li><li class="chapter-item expanded "><a href="format/configuration/environment-variables.zh.html"><strong aria-hidden="true">5.2.4.</strong> Environment Variables</a></li></ol></li><li class="chapter-item expanded "><a href="format/theme/README.zh.html"><strong aria-hidden="true">5.3.</strong> Theme</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="format/theme/index-hbs.zh.html"><strong aria-hidden="true">5.3.1.</strong> index.hbs</a></li><li class="chapter-item expanded "><a href="format/theme/syntax-highlighting.zh.html"><strong aria-hidden="true">5.3.2.</strong> Syntax highlighting</a></li><li class="chapter-item expanded "><a href="format/theme/editor.zh.html"><strong aria-hidden="true">5.3.3.</strong> Editor</a></li></ol></li><li class="chapter-item expanded "><a href="format/mathjax.zh.html"><strong aria-hidden="true">5.4.</strong> MathJax Support</a></li><li class="chapter-item expanded "><a href="format/mdbook.zh.html"><strong aria-hidden="true">5.5.</strong> mdBook-specific features</a></li><li class="chapter-item expanded "><a href="format/markdown.zh.html"><strong aria-hidden="true">5.6.</strong> Markdown</a></li></ol></li><li class="chapter-item expanded "><a href="continuous-integration.zh.html"><strong aria-hidden="true">6.</strong> Continuous Integration</a></li><li class="chapter-item expanded "><a href="for_developers/README.zh.html"><strong aria-hidden="true">7.</strong> For Developers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="for_developers/preprocessors.zh.html"><strong aria-hidden="true">7.1.</strong> Preprocessors</a></li><li class="chapter-item expanded "><a href="for_developers/backends.zh.html"><strong aria-hidden="true">7.2.</strong> Alternative Backends</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="misc/contributors.zh.html">Contributors</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">mdBook 中文文档</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/chinanf-boy/mdBook-zh" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="介绍"><a class="header" href="#介绍">介绍</a></h1>
<p><strong>mdBook</strong> 是一个命令行工具，可以将 Markdown 文档，变成 HTML 网站。
这样的工具，用在产品信息或是 API 文档, 教程, 课件资料等等场景。</p>
<ul>
<li><strong>轻量级：</strong> <a href="format/markdown.zh.html">Markdown</a> 语法</li>
<li><strong>搜索：</strong> 集成 <a href="guide/reading.zh.html#search">search</a> 功能</li>
<li><strong>语法高亮：</strong> <a href="format/theme/syntax-highlighting.zh.html">syntax highlighting</a> </li>
<li><strong>多个主题：</strong> <a href="format/theme/index.html">Theme</a> 自定义输出的格式</li>
<li><strong>预先处理器：</strong> <a href="format/configuration/preprocessors.zh.html">Preprocessors</a> 预处理的扩展，比如</li>
<li><strong>后端：</strong> <a href="format/configuration/renderers.zh.html">Backends</a> 选择输出的渲染格式</li>
<li>自然，还具有 <a href="https://www.rust-lang.org/">Rust</a> 加持，速度杠杠的。</li>
<li>甚至，<a href="cli/test.zh.html">Rust 代码</a> 的自动测试。 </li>
</ul>
<p>本指南，带你进入，快进快出的现代化文档工具。
mdBook 是 Rust 官方的项目, 还有 <a href="https://doc.rust-lang.org/book/">The Rust Programming Language</a> 也是使用 <strong>本工具</strong> 的</p>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<blockquote>
<p>译者：这就不翻译了，有心者事竟成。</p>
</blockquote>
<p>mdBook is free and open source. You can find the source code on
<a href="https://github.com/rust-lang/mdBook">GitHub</a> and issues and feature requests can be posted on
the <a href="https://github.com/rust-lang/mdBook/issues">GitHub issue tracker</a>. mdBook relies on the community to fix bugs and
add features: if you’d like to contribute, please read
the <a href="https://github.com/rust-lang/mdBook/blob/master/CONTRIBUTING.md">CONTRIBUTING</a> guide and consider opening
a <a href="https://github.com/rust-lang/mdBook/pulls">pull request</a>.</p>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>mdBook,所有源代码,都是在<a href="https://www.mozilla.org/MPL/2.0/">Mozilla Public License
v2.0</a>下发布的.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reading-books"><a class="header" href="#reading-books">Reading Books</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-a-book"><a class="header" href="#creating-a-book">Creating a Book</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-line-tool"><a class="header" href="#command-line-tool">Command Line Tool</a></h1>
<p>mdBook既可以用作命令行工具,也可以用作<a href="https://crates.io/crates/mdbook">Rust
crate</a>。让我们首先关注命令行工具功能.</p>
<h2 id="二进制"><a class="header" href="#二进制">二进制</a></h2>
<p>在尽力而为的基础上,预先编译主要平台的二进制文件。访问<a href="https://github.com/rust-lang-nursery/mdBook/releases"> releases 页面</a>下载适合您平台的版本.</p>
<h2 id="源码安装"><a class="header" href="#源码安装">源码安装</a></h2>
<p>mdBook也可以从源代码安装</p>
<h3 id="pre-requisite"><a class="header" href="#pre-requisite">Pre-requisite</a></h3>
<p>mdBook是写的 <strong><a href="https://www.rust-lang.org/">Rust</a></strong> 因此需要<strong>Cargo</strong>编译。如果您还没有安装Rust，请现在就<a href="https://www.rust-lang.org/zh-CN/tools/install">官方安装</a>。</p>
<h3 id="安装-cratesio-的版本"><a class="header" href="#安装-cratesio-的版本">安装 Crates.io 的版本</a></h3>
<p>如果您已安装Rust和Cargo,则安装mdBook相当容易。您只需在终端中键入以下代码段:</p>
<pre><code class="language-bash">cargo install mdbook
</code></pre>
<p>这将在<a href="https://crates.io/">Crates.io</a>获取最新版本的源代码，并编译它。你需要添加Cargo的<code>bin</code>目录，到你的环境变量<code>PATH</code>.</p>
<p>在您的终端，运行<code>mdbook help</code>验证它是否有效。</p>
<p>恭喜你,你已经安装了mdBook!</p>
<h3 id="安装-git-版本"><a class="header" href="#安装-git-版本">安装 Git 版本</a></h3>
<p>该 <strong><a href="https://github.com/rust-lang-nursery/mdBook">git 版本</a></strong> 包含所有最新的错误修复和功能, 且是在下一个版本中才发布<strong>Crates.io</strong>, 如果你不能等到下一个版本。你可以自己构建git版本。打开终端，并导航到您选择的目录。我们需要克隆git存储库,然后使用Cargo构建它.</p>
<pre><code class="language-bash">git clone --depth=1 https://github.com/rust-lang-nursery/mdBook.git
cd mdBook
cargo build --release
</code></pre>
<p>可执行文件<code>mdbook</code>输出在<code>./target/release</code>文件夹,这应该添加到环境变量<code>PATH</code>中，方便使用。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="init-命令"><a class="header" href="#init-命令">init 命令</a></h1>
<p>每本新书都有一些最小的样板。为此目的,mdBook支持<code>init</code>命令.</p>
<p><code>init</code>命令使用如下:</p>
<pre><code class="language-bash">mdbook init
</code></pre>
<p>第一次使用<code>init</code>命令,将为您设置几个文件:</p>
<pre><code class="language-bash">book-test/
├── book
└── src
    ├── chapter_1.md
    └── SUMMARY.md
</code></pre>
<ul>
<li>
<p><code>src</code>目录是你在写的markdown书。它包含所有源文件,配置文件等.</p>
</li>
<li>
<p><code>book</code>目录是您的书html页面输出的位置。所有输出都可以上传到服务器,供观众查看.</p>
</li>
<li>
<p><code>SUMMARY.md</code>文件是最重要的文件,它是您图书的骨架,并将在<a href="cli/../format/summary.html">其他章节</a>进行更详细的讨论</p>
</li>
</ul>
<h4 id="tip-根据-summarymd-生成"><a class="header" href="#tip-根据-summarymd-生成">Tip: 根据 SUMMARY.md 生成</a></h4>
<p>当一个<code>SUMMARY.md</code>文件已存在,<code>init</code>命令将首先解析它，并根据<code>SUMMARY.md</code>中，帮其补全丢失的文件路径。这允许您思考和创建书的整个结构,然后让mdBook为您生成它.</p>
<h4 id="指定目录"><a class="header" href="#指定目录">指定目录</a></h4>
<p><code>init</code>命令可以将目录作为参数，用作本书的根目录，而不是当前工作目录.</p>
<pre><code class="language-bash">mdbook init path/to/book
</code></pre>
<h4 id="theme"><a class="header" href="#theme">–theme</a></h4>
<p>当你使用<code>--theme</code>,默认主题将被复制到一个名为<code>theme</code>的目录.</p>
<blockquote>
<p>在您的源目录中,以便您可以修改它.</p>
</blockquote>
<p>主题会被选择性地覆盖,这意味着如果您不想覆盖,只需删除它,就会使用默认文件.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-命令"><a class="header" href="#build-命令">build 命令</a></h1>
<p>构建命令,用于渲染您的 md,并输出静态 html:</p>
<pre><code class="language-bash">mdbook build
</code></pre>
<p>它会尝试解析你的<code>SUMMARY.md</code>文件，以了解您的图书的结构并获取相应的文件.</p>
<p>为方便起见,渲染的输出将保持与源目录结构相同。因此,大型书籍在渲染时能保持结构化.</p>
<h4 id="指定目录-1"><a class="header" href="#指定目录-1">指定目录</a></h4>
<p><code>build</code>命令可以将目录作为参数，用作本书的根目录，而不是当前工作目录.</p>
<pre><code class="language-bash">mdbook build path/to/book
</code></pre>
<h4 id="open"><a class="header" href="#open">–open</a></h4>
<p>当你使用<code>--open</code>(<code>-o</code>),mdbook 将在构建之后，在默认 Web 浏览器中打开网页书.</p>
<h4 id="dest-dir"><a class="header" href="#dest-dir">–dest-dir</a></h4>
<p><code>--dest-dir</code>(<code>-d</code>)选项允许您更改书籍的输出目录。为相对路径，（相对于书籍的根目录）。如果未指定,则默认为<code>book.toml</code>配置的<code>build.build-dir</code>字段, 或者<code>./book</code>目录.</p>
<hr />
<p><strong><em>注意:</em></strong> <em>确保在根目录中运行 build 命令,而不是在源<code>src</code>目录中运行</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="watch-命令"><a class="header" href="#watch-命令">watch 命令</a></h1>
<p>当您希望在每次更改文件，都生成图书时, <code>watch</code>命令会很有用。你当然可以在每次更改文件反复发出<code>mdbook build</code>。但，聪明的是使用<code>mdbook watch</code>，这样就能观察您的文件,并会在您修改文件时，自动触发构建.</p>
<h4 id="指定目录-2"><a class="header" href="#指定目录-2">指定目录</a></h4>
<p><code>watch</code>命令可以将目录作为参数，用作本书的根目录，而不是当前工作目录.</p>
<pre><code class="language-bash">mdbook watch path/to/book
</code></pre>
<h4 id="open-1"><a class="header" href="#open-1">–open</a></h4>
<p>当你使用<code>--open</code>(<code>-o</code>)选项,mdbook 将在您的默认 Web 浏览器中打开网页书.</p>
<h4 id="dest-dir-1"><a class="header" href="#dest-dir-1">–dest-dir</a></h4>
<p><code>--dest-dir</code>(<code>-d</code>)选项允许您更改书籍的输出目录。为相对路径，（相对于书籍的根目录）。如果未指定,则默认为<code>book.toml</code>配置的<code>build.build-dir</code>字段, 或者<code>./book</code>目录.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-serve-command"><a class="header" href="#the-serve-command">The serve command</a></h1>
<p>serve 命令用于通过 HTTP 服务来预览书籍，默认情况下<code>localhost:3000</code>。此外,它还会观察图书的目录的更改,自动重建图书，以及为每次更改刷新客户端。</p>
<blockquote>
<p>websocket 连接用于触发客户端刷新.</p>
</blockquote>
<p><strong><em>注意:</em></strong> <em><code>serve</code>命令用于测试书籍的 HTML 输出,并不打算成为网站的完整 HTTP 服务器.</em></p>
<h4 id="指定目录-3"><a class="header" href="#指定目录-3">指定目录</a></h4>
<p><code>serve</code>命令可以将目录作为参数，用作本书的根目录，而不是当前工作目录.</p>
<pre><code class="language-bash">mdbook serve path/to/book
</code></pre>
<h4 id="server-选项"><a class="header" href="#server-选项">Server 选项</a></h4>
<p><code>serve</code>有四个选项:</p>
<ul>
<li>HTTP 端口,</li>
<li>WebSocket 端口,</li>
<li>要侦听的 HTTP 主机名,以及</li>
<li>要连接到 WebSockets 的浏览器的主机名.</li>
</ul>
<p>例如:假设您有一个公共地址为 192.168.1.100，可用 SSL 终止符 的 nginx 服务器,其端口 80 , 在127.0.0.1的 8000端口 上代理。要运行使用 nginx 代理,请执行以下操作:</p>
<pre><code class="language-bash">mdbook serve path/to/book -p 8000 -n 127.0.0.1 --websocket-hostname 192.168.1.100
</code></pre>
<p>如果你想要实时重新加载,你需要通过 nginx 来代理 websocket 调用<code>192.168.1.100:&lt;WS_PORT&gt;</code>到<code>127.0.0.1:&lt;WS_PORT&gt;</code>。</p>
<p><code>-w</code>选项会允许配置 websocket 端口.</p>
<h4 id="open-2"><a class="header" href="#open-2">–open</a></h4>
<p>当你使用<code>--open</code>(<code>-o</code>)标志,mdbook 将在启动服务器后,在您的默认 Web 浏览器中打开该书.</p>
<h4 id="dest-dir-2"><a class="header" href="#dest-dir-2">–dest-dir</a></h4>
<p><code>--dest-dir</code>(<code>-d</code>)选项允许您更改书籍的输出目录。为相对路径，（相对于书籍的根目录）。如果未指定,则默认为<code>book.toml</code>配置的<code>build.build-dir</code>字段, 或者<code>./book</code>目录.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="test-命令"><a class="header" href="#test-命令">test 命令</a></h1>
<p>写书时,有时需要一些自动化测试.例如,<a href="https://doc.rust-lang.org/stable/book/">The Rust Programming Book</a>使用了许多可能过时的代码示例。因此,能够自动测试这些代码示例对他们来说非常重要.</p>
<p>mdBook 支持<code>test</code>将运行，书中所有可用测试的命令。目前,只支持 rustdoc 测试,但未来可能会扩展.</p>
<h4 id="在一个代码块禁用测试"><a class="header" href="#在一个代码块禁用测试">在一个代码块，禁用测试</a></h4>
<p>rustdoc 不会测试，包含<code>ignore</code>属性的代码块:</p>
<pre><code>```rust,ignore
fn main() {}
```
</code></pre>
<p>rustdoc 也不会测试，指定了除 Rust 之外的语言的代码块:</p>
<pre><code>```markdown
**Foo**: _bar_
```
</code></pre>
<p>rustdoc<em>不会</em>测试，没有指定语言的代码块:</p>
<pre><code>```
This is going to cause an error!
```
</code></pre>
<h4 id="指定目录-4"><a class="header" href="#指定目录-4">指定目录</a></h4>
<p><code>test</code>命令可以将目录作为参数，用作本书的根目录，而不是当前工作目录.</p>
<pre><code class="language-bash">mdbook test path/to/book
</code></pre>
<h4 id="library-path"><a class="header" href="#library-path">–library-path</a></h4>
<p><code>--library-path</code>(<code>-L</code>)选项允许您，当<code>rustdoc</code>构建和测试示例时，将目录添加到搜索路径。可以指定多个目录(<code>-L foo -L bar</code>)，或用逗号分隔的列表(<code>-L foo,bar</code>).</p>
<h4 id="dest-dir-3"><a class="header" href="#dest-dir-3">–dest-dir</a></h4>
<p><code>--dest-dir</code>(<code>-d</code>)选项允许您更改书籍的输出目录。为相对路径，（相对于书籍的根目录）。如果未指定,则默认为<code>book.toml</code>配置的<code>build.build-dir</code>字段, 或者<code>./book</code>目录.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="clean-命令"><a class="header" href="#clean-命令">clean 命令</a></h1>
<p>clean 命令用于删除生成的书籍，和任何其他构建工件.</p>
<pre><code class="language-bash">mdbook clean
</code></pre>
<h4 id="指定目录-5"><a class="header" href="#指定目录-5">指定目录</a></h4>
<p><code>clean</code>命令可以将目录作为参数，用作本书的根目录，而不是当前工作目录.</p>
<pre><code class="language-bash">mdbook clean path/to/book
</code></pre>
<h4 id="dest-dir-4"><a class="header" href="#dest-dir-4">–dest-dir</a></h4>
<p><code>--dest-dir</code>(<code>-d</code>)选项允许您覆盖书籍的输出目录,该目录会删除。
为相对路径，（相对于书籍的根目录）。如果未指定,则默认为<code>book.toml</code>配置的<code>build.build-dir</code>字段, 或者<code>./book</code>目录.</p>
<pre><code class="language-bash">mdbook clean --dest-dir=path/to/book
</code></pre>
<p><code>path/to/book</code>可以是绝对的，或相对的.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="completions"><a class="header" href="#completions">completions</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="格式"><a class="header" href="#格式">格式</a></h1>
<p>在本节中,您将学习如何:</p>
<ul>
<li>正确构建您的书</li>
<li>格式化你的<code>SUMMARY.md</code>文件</li>
<li>使用<code>book.toml</code>配置您的图书</li>
<li>自定义主题</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="summarymd"><a class="header" href="#summarymd">SUMMARY.md</a></h1>
<p>mdBook使用Summary文件，来了解要书的章节,应显示的顺序,层次结构以及源文件的位置。<strong>没有这个文件,就没有书.</strong></p>
<p>即使<code>SUMMARY.md</code>是一个markdown文件, 但格式是非常严格,以便于给mdbook解析。我们来看看你应该如何格式化你的<code>SUMMARY.md</code>文件.</p>
<h4 id="允许的-elements"><a class="header" href="#允许的-elements">允许的 elements</a></h4>
<ol>
<li>
<p><em><strong>Title</strong></em>一般来说,通常以<code
class="language-markdown"># Summary</code>.标题开头是常见的做法，但它不是强制性的,解析器只是忽略它.如果你也是这样想,也忽略它。</p>
</li>
<li>
<p><em><strong>开头章节</strong></em>位于主编号章节前,您可以添加一些不编号的元素。这对<code>前言,介绍</code>等很有用.但是有一些限制。你不能嵌套开头章节,它们都应该在根级别.一旦添加了编号章节,就无法添加开头章节.</p>
<pre><code class="language-markdown">[开头章节的标题](relative/path/to/markdown.md)
</code></pre>
</li>
<li>
<p><em><strong>编号章节</strong></em>是本书的主要内容,它们将被编号，并可以嵌套,从而产生一个很好的层次结构(章节,子章节等)</p>
<pre><code class="language-markdown">- [编号章节的标题](relative/path/to/markdown.md)
</code></pre>
<p>你可以使用<code>-</code>或<code>*</code>表示编号的章节.</p>
</li>
<li>
<p><em><strong>结尾章节</strong></em>位于在编号章节后,您可以添加几个未编号的章节.它们与开头章节相同,但是在编号章节之后，而不是之前.</p>
</li>
</ol>
<p>所有其他元素都不受支持,最多将被忽略或导致错误.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration"><a class="header" href="#configuration">Configuration</a></h1>
<p>本节详细介绍了中可用的配置选项<em><strong>书汤姆</strong></em>:</p>
<ul>
<li>**<a href="format/configuration/general.html">General</a>**配置，包括<code>book</code>, <code>rust</code>, <code>build</code>部分</li>
<li>**<a href="format/configuration/preprocessors.html">Preprocessor</a>**默认和自定义图书预处理器的配置</li>
<li>**<a href="format/configuration/renderers.html">Renderer</a>**HTML、标记和自定义渲染器的配置</li>
<li>**<a href="format/configuration/environment-variables.html">Environment Variable</a>**用于覆盖环境中的配置选项的配置</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="general"><a class="header" href="#general">General</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="preprocessors"><a class="header" href="#preprocessors">Preprocessors</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="renderers"><a class="header" href="#renderers">Renderers</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="environment-variables"><a class="header" href="#environment-variables">Environment Variables</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="theme-1"><a class="header" href="#theme-1">Theme</a></h1>
<p>默认渲染器使用一个<a href="http://handlebarsjs.com/">handlebars</a>模板，用于渲染markdown文件,并mdBook二进制文件包含默认主题.</p>
<p>主题是完全可定制的,您可以通过在根目录<code>src</code>旁边，新建一个<code>theme</code>文件夹，在其中选择性地添加文件名称，覆盖主题的任意文件。</p>
<table><thead><tr><th>以下是您可以覆盖的文件:</th><th>描述</th></tr></thead><tbody>
<tr><td><strong>index.hbs</strong></td><td>hbs模板.</td></tr>
<tr><td><strong>book.css</strong></td><td>是输出中使用的样式。如果要更改图书的设计,可能是您要修改的文件。有时与<code>index.hbs</code>一起，当你想从根本上改变布局.</td></tr>
<tr><td><strong>book.js</strong></td><td>主要用于添加客户端功能,如隐藏/取消隐藏侧边栏,更改主题,…</td></tr>
<tr><td><strong>highlight.js</strong></td><td>是用于突出显示代码片段的JavaScript,您不需要修改它.</td></tr>
<tr><td><strong>highlight.css</strong></td><td>是用于代码突出显示的主题</td></tr>
<tr><td><strong>favicon.png</strong></td><td>将使用的favicon</td></tr>
</tbody></table>
<p>通常,当您想要调整主题时,您不需要覆盖所有文件。如果您只需要更改css样式表,那么覆盖所有其他文件是没有意义的。由于自定义文件优先于内置文件，那以后的新的修补程序/功能，你都更新不了。</p>
<p><strong>注意:</strong> 覆盖文件时,可能会破坏某些功能。因此,我建议使用默认主题中的文件作为模板,只添加/修改您需要的内容。您可以使用<code>mdbook init --theme</code>命令自动将默认主题自动复制到源目录中，只需删除您不想覆盖的文件.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="indexhbs"><a class="header" href="#indexhbs">index.hbs</a></h1>
<p><code>index.hbs</code>是用于渲染书籍的hbs模板。markdown文件被处理为html,然后注入该模板.</p>
<p>如果您想更改图书的布局或样式,您可能需要稍微修改此模板。那下面是你需要知道的。</p>
<h2 id="data"><a class="header" href="#data">Data</a></h2>
<p>大量数据通过“上下文“暴露给hbs模板.在hbs模板中,您可以使用以下方式访问此信息</p>
<pre><code class="language-handlebars">{{name_of_property}}
</code></pre>
<p>以下是公开的属性列表: </p>
<ul>
<li><strong>language</strong> |&gt; 书的语言<code>en</code>。例如<code>&lt;code class=&quot;language-html&quot;&gt;\\&lt;html lang=&quot;{{ language }}&quot;&gt;&lt;/code&gt;</code>。</li>
<li><strong>title</strong> |&gt; 该书的标题,如<code>book.toml</code>中所述</li>
<li><strong>chapter_title</strong> |&gt; 本章的标题,如<code>SUMMARY.md</code>下所列</li>
<li><strong>path</strong> |&gt; 源目录中原始markdown文件的相对路径</li>
<li><strong>content</strong> |&gt; 这是渲染的markdown.</li>
<li><strong>path_to_root</strong> |&gt; 这是一条完全包含<code>../</code>的路径，这会是从当前文件指向书的根。由于维护了原始目录结构,因此使用此前缀相对链接很有用.</li>
<li><strong>chapters</strong> |&gt; 是一个字典数组</li>
</ul>
<pre><code class="language-json">{&quot;section&quot;: &quot;1.2.1&quot;, &quot;name&quot;: &quot;name of this chapter&quot;, &quot;path&quot;: &quot;dir/markdown.md&quot;}
</code></pre>
<p>包含本书的所有章节.它用于例如构建目录(侧边栏).</p>
<h2 id="handlebars-帮手"><a class="header" href="#handlebars-帮手">Handlebars 帮手</a></h2>
<p>除了您可以访问的属性外,您还可以使用一些hbs帮手.</p>
<h3 id="1-toc"><a class="header" href="#1-toc">1. toc</a></h3>
<pre><code>toc助手就像这样使用

```handlebars
{{#toc}}{{/toc}}
```

并输出看起来像这样的东西，这取决于你的书的结构

```html
&lt;ul class=&quot;chapter&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;link/to/file.html&quot;&gt;Some chapter&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;
        &lt;ul class=&quot;section&quot;&gt;
            &lt;li&gt;&lt;a href=&quot;link/to/other_file.html&quot;&gt;Some other Chapter&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/li&gt;
&lt;/ul&gt;
```

如果您想使用其他结构创建一个toc，则可以访问包含所有数据的chapters属性。
目前唯一的限制是您必须使用JavaScript,而不是使用hbs帮助程序。

```html
&lt;script&gt;
var chapters = {{chapters}};
// Processing here
&lt;/script&gt;
```
</code></pre>
<h3 id="2-previous--next"><a class="header" href="#2-previous--next">2. previous / next</a></h3>
<pre><code>上一个和下一个助手将`link`和`name`属性暴露给前一章和下一章。

就像这样使用

```handlebars
{{#previous}}
    &lt;a href=&quot;{{link}}&quot; class=&quot;nav-chapters previous&quot;&gt;
        &lt;i class=&quot;fa fa-angle-left&quot;&gt;&lt;/i&gt;
    &lt;/a&gt;
{{/previous}}
```

只有在前一个/下一个章节存在时,才会渲染内部html。
当然内部html可以根据自己的喜好进行更改。
</code></pre>
<hr />
<p><em>如果您希望其他属性或帮手,请<a href="https://github.com/rust-lang-nursery/mdBook/issues">create a new
issue</a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="语法高亮"><a class="header" href="#语法高亮">语法高亮</a></h1>
<p>对于我使用的语法高亮<a href="https://highlightjs.org">Highlight.js</a>自定义主题.</p>
<p>自动语言检测已关闭,因此您可能希望指定您使用的编程语言</p>
<pre><code class="language-markdown">```rust
fn main() {
    // Some code
}
```</code></pre>
<h2 id="自定义主题"><a class="header" href="#自定义主题">自定义主题</a></h2>
<p>与主题的其余部分一样,用于语法突出显示的css，可以使用您自己的文件覆盖.</p>
<ul>
<li><em><strong>highlight.js</strong></em> 通常你不应该覆盖这个文件,除非你想使用更新的版本.</li>
<li><em><strong>highlight.css</strong></em> highlight.js用于语法高亮的主题.</li>
</ul>
<p>如果你想使用<code>highlight.js</code>另一个主题,可从他们的网站下载,或自己制作,重命名为<code>highlight.css</code>，并把它放进去<code>src/theme</code>(或等效的,如果您更改了源文件夹)</p>
<p>现在将使用您的主题，而不是默认主题.</p>
<h2 id="隐藏代码行数"><a class="header" href="#隐藏代码行数">隐藏代码行数</a></h2>
<p>mdBook中有一个功能,可以通过在代码行前加上来隐藏代码行<code>#</code>.</p>
<pre><code class="language-bash"># fn main() {
    let x = 5;
    let y = 6;

    println!(&quot;{}&quot;, x + y);
# }
</code></pre>
<p>将渲染为</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">fn main() {
</span>    let x = 5;
    let y = 7;

    println!(&quot;{}&quot;, x + y);
<span class="boring">}
</span></code></pre></pre>
<p><strong>目前,这仅适用于带注释的代码示例<code>rust</code>。因为它会与某些编程语言的语义冲突.在未来,我们希望通过这个，可在<code>book.toml</code>配置，这样每个人都可以从中受益.</strong></p>
<h2 id="加强默认主题"><a class="header" href="#加强默认主题">加强默认主题</a></h2>
<p>如果您认为默认主题看起来不适合特定语言,或者可以改进。随意地<a href="https://github.com/rust-lang-nursery/mdBook/issues">submit a new
issue</a>解释你的想法,我会看看它.</p>
<p>您还可以使用建议的改进创建拉取请求.</p>
<p>总的来说,主题应该是清淡和清醒,没有许多华丽的颜色.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="编辑器"><a class="header" href="#编辑器">编辑器</a></h1>
<p>除了提供可运行的代码playpens之外,mdBook还可以选择进行编辑。为了启用可编辑的代码块,需要添加以下内容<em><strong>book.toml</strong></em>:</p>
<pre><code class="language-toml">[output.html.playpen]
editable = true
</code></pre>
<p>要使特定块可用于编辑,请使用该属性<code>editable</code>添加:</p>
<pre><code class="language-markdown">```rust,editable
fn main() {
    let number = 5;
    print!("{}", number);
}
```</code></pre>
<p>以上将导致这个可编辑的围栏:</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn main() {
    let number = 5;
    print!(&quot;{}&quot;, number);
}
</code></pre></pre>
<p>注意新的<code>Undo Changes</code>的按钮会出现在可编辑的playpens中.</p>
<h2 id="定制编辑器"><a class="header" href="#定制编辑器">定制编辑器</a></h2>
<p>默认情况下,编辑器是<a href="https://ace.c9.io/">Ace</a>编辑器,但是,如果需要,可以通过提供不同的文件夹来覆盖功能:</p>
<pre><code class="language-toml">[output.html.playpen]
editable = true
editor = &quot;/path/to/editor&quot;
</code></pre>
<p>请注意,要让编辑器更改正常运行,<code>book.js</code>里面的<code>theme</code>文件夹，你需要覆盖下,因为它与默认的Ace编辑器有一些耦合.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mathjax-支持"><a class="header" href="#mathjax-支持">MathJax 支持</a></h1>
<p>mdBook，可选的支持数学方程式<a href="https://www.mathjax.org/">MathJax</a>.</p>
<p>要启用MathJax,您需要在<code>book.toml</code>中的<code>output.html</code>部分添加<code>mathjax-support</code>，.</p>
<pre><code class="language-toml">[output.html]
mathjax-support = true
</code></pre>
<blockquote>
<p><strong>注意:</strong> MathJax使用的常用分隔符尚不支持.你目前无法使用<code>$$ ... $$</code>作为分隔符和<code>\[ ... \]</code>分隔符需要额外的反斜杠才能工作。希望这个限制很快就会解除.</p>
<p><strong>注意:</strong> 在MathJax块中使用双反斜杠时(例如在诸如<code>\begin{cases} \frac 1 2 \\ \frac 3 4 \end{cases}</code>之类的命令中)你需要添加<em>另外两个</em>反斜杠(例如,<code>\begin{cases} \frac 1 2 \\\\ \frac 3 4 \end{cases}</code>).</p>
</blockquote>
<h3 id="内联方程"><a class="header" href="#内联方程">内联方程</a></h3>
<p>内联方程由以下分隔<code>\\(</code>和<code>\\)</code>。例如,渲染以下内联方程\(\ int x dx = \ frac {x ^ 2} {2} + C.\)，你要写下面的内容:</p>
<pre><code>\\( \int x dx = \frac{x^2}{2} + C \\)
</code></pre>
<h3 id="块方程"><a class="header" href="#块方程">块方程</a></h3>
<p>块方程由以下分隔<code>\\[</code>和<code>\\]</code>.要渲染以下等式</p>
<p>\[\ mu = \ frac {1}{ }N\ _{ sum= }i _ 0\ xi]</p>
<p>你会写:</p>
<pre><code class="language-bash">\\[ \mu = \frac{1}{N} \sum_{i=0} x_i \\]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mdbook-特有-markdown"><a class="header" href="#mdbook-特有-markdown">mdBook 特有 markdown</a></h1>
<h2 id="隐藏代码行数-1"><a class="header" href="#隐藏代码行数-1">隐藏代码行数</a></h2>
<p>mdBook 中有一个功能,可以通过在代码行前加上<code>#</code>来隐藏代码行.</p>
<pre><code class="language-bash"># fn main() {
    let x = 5;
    let y = 6;

    println!(&quot;{}&quot;, x + y);
# }
</code></pre>
<p>渲染为</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">fn main() {
</span>    let x = 5;
    let y = 7;

    println!(&quot;{}&quot;, x + y);
<span class="boring">}
</span></code></pre></pre>
<h2 id="include包含文件内容"><a class="header" href="#include包含文件内容">include，包含文件内容</a></h2>
<p>使用以下语法,您可以将文件包含到您的书中:</p>
<pre><code class="language-hbs">{{#include file.rs}}
</code></pre>
<p>文件的路径必须是 <strong>当前</strong> 源文件的 <strong>相对</strong> 路径.</p>
<p>通常,此命令用于包含代码段和示例。在这种情况下, 可指定文件的包含部分,例如其中只包含示例的相关行.</p>
<p>mdBook 会将 include 文件 解释成 markdown。 自从 include 命令常用来插入代码片段和示例，你会习惯使用 <code>```</code> 包裹这些命令，显示（include）文件的内容，而不是去解释它们。</p>
<pre><code class="language-hbs">```
{{#include file.rs}}
```
</code></pre>
<h2 id="只-include-一个文件的部分内容"><a class="header" href="#只-include-一个文件的部分内容">只 Include 一个文件的部分内容</a></h2>
<p>常见要求是你只要文件的部分内容 e.g. 以行编号作为例子。我们对部分内容插入，支持了几种模式:</p>
<pre><code class="language-hbs">{{#include file.rs:2}}
{{#include file.rs::10}}
{{#include file.rs:2:}}
{{#include file.rs:2:10}}
</code></pre>
<p>我们支持四种不同的决定<code>file.rs</code>部分模式:</p>
<ul>
<li>第一个命令仅包含文件中的第二行.</li>
<li>第二个命令包含直到第 10 行的所有行。即,从 11 到文件末尾的行被省略.</li>
<li>第三个命令包含第 2 行的所有行,即省略第一行.</li>
<li>最后一个命令包含摘录<code>file.rs</code>由 2 到 10 行组成.</li>
</ul>
<p>为了防止文件的修改（行数的变化），导致图书呈现内容的变化, 你还可以使用锚点(anchor)，选择一个特定的部分，
行数就不再相关。
一个 anchor 是一对匹配的行。 匹配的内容正是正则式，如开头的行anchor必须匹配“ANCHOR:\s*[\w_-]+“ and similarly 结尾行则是 “ANCHOR_END:\s*[\w_-]+”。只要内容匹配了，注释的写法格式倒是没有限制。</p>
<p>考虑下面 要 include 的文件:</p>
<pre><code class="language-rs">/* ANCHOR: all */

// ANCHOR: component
struct Paddle {
    hello: f32,
}
// ANCHOR_END: component

////////// ANCHOR: system
impl System for MySystem { ... }
////////// ANCHOR_END: system

/* ANCHOR_END: all */
</code></pre>
<p>给个示例，你要做的:</p>
<pre><code class="language-hbs">Here is a component:
```rust,no_run,noplaypen
{{#include file.rs:component}}
```

Here is a system:
```rust,no_run,noplaypen
{{#include file.rs:system}}
```

This is the full file.
```rust,no_run,noplaypen
{{#include file.rs:all}}
```
</code></pre>
<p>在已 include anchor 内的，若还包含 anchor 匹配模式，则会被忽略。</p>
<h2 id="插入可运行的-rust-文件"><a class="header" href="#插入可运行的-rust-文件">插入可运行的 Rust 文件</a></h2>
<p>使用以下语法,您可以将可运行的 Rust 文件插入到您的书中:</p>
<pre><code class="language-hbs">{{#playground file.rs}}
</code></pre>
<p>Rust 文件的路径必须是当前源文件的相对路径.</p>
<p>点击播放后,代码段将被发送到<a href="https://play.rust-lang.org/">rust 的游乐场</a>编译和运行。结果被返回，并直接显示在代码下方.</p>
<p>以下是代码段的渲染的样子:</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
    println!(&quot;Hello World!&quot;);
<span class="boring">
</span><span class="boring">   // You can even hide lines! :D
</span><span class="boring">  println!(&quot;I am hidden! Expand the code snippet to see me&quot;);
</span>}
</code></pre></pre>
<blockquote>
<p>试试 点击 播放箭头</p>
</blockquote>
<h3 id="要可编辑请添加"><a class="header" href="#要可编辑请添加">要可编辑，请添加</a></h3>
<pre><code class="language-hbs">{{#playground example.rs editable no_run should_panic}}
</code></pre>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn main() {
    println!(&quot;Hello World!&quot;);
<span class="boring">
</span><span class="boring">   // You can even hide lines! :D
</span><span class="boring">  println!(&quot;I am hidden! Expand the code snippet to see me&quot;);
</span>}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="markdown"><a class="header" href="#markdown">Markdown</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="在持续集成中运行-mdbook"><a class="header" href="#在持续集成中运行-mdbook">在持续集成中运行 <code>mdbook</code></a></h1>
<p>虽然以下示例中使用在Travis CI,但原则上应该，也可以直接转移到其他持续集成提供商.</p>
<h2 id="确保mdbook的构建与测试成功"><a class="header" href="#确保mdbook的构建与测试成功">确保mdbook的构建与测试成功</a></h2>
<p>以下是Travis CI的<code>.travis.yml</code>示例，确保配置了<code>mdbook build</code>和<code>mdbook test</code>运行成功。加快CI运转时间的关键是缓存<code>mdbook</code>的安装,以便您可以不用每次CI运行就编译一次<code>mdbook</code>。</p>
<pre><code class="language-yaml">language: rust
sudo: false

cache:
  - cargo

rust:
  - stable

before_script:
  - (test -x $HOME/.cargo/bin/cargo-install-update || cargo install cargo-update)
  - (test -x $HOME/.cargo/bin/mdbook || cargo install --vers &quot;^0.3&quot; mdbook)
  - cargo install-update -a

script:
  - mdbook build path/to/mybook &amp;&amp; mdbook test path/to/mybook
</code></pre>
<h2 id="发布你的图书到-github-pages"><a class="header" href="#发布你的图书到-github-pages">发布你的图书到 GitHub Pages</a></h2>
<p>遵循这些命令的结果是，在您的存储库运行CI成功后,您的图书将发布到GitHub页面的<code>master</code>分支.</p>
<p>首先,创建一个新的GitHub的“Personal Access Token“，保证“public_repo“权限(或私有存储库的“repo“)。转到Travis CI网站的该库设置页面，并添加一个名为<code>GITHUB_TOKEN</code>的环境变量，该变量能保证安全和<em>不</em>显示在日志中.</p>
<p>然后,将此代码段附加到您的<code>.travis.yml</code>，并更新为<code>book</code>目录路径:</p>
<blockquote>
<p><code>book</code>目录是<code>mdbook build</code>的默认输出目录，请根据你的构建目录填写</p>
</blockquote>
<pre><code class="language-yaml">deploy:
  provider: pages
  skip-cleanup: true
  github-token: $GITHUB_TOKEN
  local-dir: path/to/mybook/book
  keep-history: false
  on:
    branch: master
</code></pre>
<p>就这样!</p>
<h3 id="手动发布你的图书到-github-pages"><a class="header" href="#手动发布你的图书到-github-pages">手动发布你的图书到 Github Pages</a></h3>
<p>如果你的 CI 并不支持 GitHub pages, 或是与其他平台进行整合:
<em>注意: 不要求一定是 tmp 目录</em>:</p>
<pre><code class="language-console">$&gt; git worktree add /tmp/book gh-pages
$&gt; mdbook build
$&gt; rm -rf /tmp/book/* # this won't delete the .git directory
$&gt; cp -rp book/* /tmp/book/
$&gt; cd /tmp/book
$&gt; git add -A
$&gt; git commit 'new book message'
$&gt; git push origin gh-pages
$&gt; cd -
</code></pre>
<p>或是放入 Makefile 文件:</p>
<pre><code class="language-makefile">.PHONY: deploy
deploy: book
	@echo &quot;====&gt; deploying to github&quot;
	git worktree add /tmp/book gh-pages
	rm -rf /tmp/book/*
	cp -rp book/* /tmp/book/
	cd /tmp/book &amp;&amp; \
		git add -A &amp;&amp; \
		git commit -m &quot;deployed on $(shell date) by ${USER}&quot; &amp;&amp; \
		git push origin gh-pages
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="致-developers"><a class="header" href="#致-developers">致 Developers</a></h1>
<p>虽然<code>mdbook</code>主要用作命令行工具, 但您也可以直接导入底层库，并使用它来管理书籍。它还具有相当灵活的插件机制，允许您创建自己的自定义工具和消费者(通常称为<em>后端</em>)，如果您需要对书籍进行一些分析，或以不同的格式渲染它.</p>
<p>该<em>对于开发人员</em>章节在这里向您展示<code>mdbook</code>更高级的用法.</p>
<p>开发人员可以通过以下两种方式，影响本书的构建过程,</p>
<ul>
<li><a href="for_developers/preprocessors.html">Preprocessors-预处理器</a></li>
<li><a href="for_developers/backends.html">Alternate Backends - 备用后端</a></li>
</ul>
<h2 id="构建过程"><a class="header" href="#构建过程">构建过程</a></h2>
<p>渲染图书项目的过程经历了几个步骤.</p>
<ol>
<li>加载书
<ul>
<li>解析<code>book.toml</code>。 如果其中不存在，使用<code>Config</code>默认值。</li>
<li>将书籍章节加载到内存中</li>
<li>了解应该使用哪些预处理器/后端</li>
</ul>
</li>
<li>运行预处理器</li>
<li>依次运行每个后端</li>
</ol>
<h2 id="mdbook作为库使用"><a class="header" href="#mdbook作为库使用"><code>mdbook</code>作为库使用</a></h2>
<p><code>mdbook</code>二进制只是一个<code>mdbook</code>箱的包装器,将其功能暴露出来，作为命令行程序。因此,很容易自制使用<code>mdbook</code>的程序,并添加自己的功能(例如自定义预处理器)或调整构建过程.</p>
<p>如何找到使用<code>mdbook</code>箱子最简单方法，答案就是<a href="https://docs.rs/mdbook/*/mdbook/">API文档</a>。顶级API文档解释了如何使用<a href="https://docs.rs/mdbook/*/mdbook/book/struct.MDBook.html"><code>MDBook</code></a>类型，加载和构建一本书,而<a href="https://docs.rs/mdbook/*/mdbook/config/index.html">config</a>模块很好地解释了配置系统.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="preprocessors-1"><a class="header" href="#preprocessors-1">Preprocessors</a></h1>
<p>一个<em>预处理器</em>只是一些代码，运行在加载书之后,和渲染之前,允许您更新和改变本书。可能的用例是:</p>
<ul>
<li>创建自定义帮助程序<code>{{#include /path/to/file.md}}</code></li>
<li>更新链接<code>[some chapter](some_chapter.md)</code>自动更改为<code>[some chapter](some_chapter.html)</code>，这是 HTML 渲染器功能</li>
<li>用 latex 样式(<code>$$ \frac{1}{3} $$</code>)的表达式代替为 mathjax 的等价物</li>
</ul>
<h2 id="勾住-mdbook"><a class="header" href="#勾住-mdbook">勾住 MDBook</a></h2>
<p>MDBook 使用一种相当简单的机制来发现第三方插件。<code>book.toml</code>添加了一个新表格(例如<code>preprocessor.foo</code>，给<code>foo</code>预处理器)，然后<code>mdbook</code>将尝试调用<code>mdbook-foo</code>程序，作为构建过程的一部分.</p>
<p>虽然预处理器可以进行硬编码,以指定应该运行哪个后端，来处理如<code>preprocessor.foo.renderer</code>的字段(但奇奇怪怪的是，像 MathJax 用于非 HTML 渲染器没有意义).</p>
<pre><code class="language-toml">[book]
title = &quot;My Book&quot;
authors = [&quot;Michael-F-Bryan&quot;]

[preprocessor.foo]
# 指定命令的使用
command = &quot;python3 /path/to/foo.py&quot;
#  `foo` 预处理器 只被用于 HTML 和 EPUB 的渲染器
renderer = [&quot;html&quot;, &quot;epub&quot;]
</code></pre>
<p>在典型的 unix 样式中,插件的所有输入都被写入<code>stdin</code>作为 JSON，和<code>mdbook</code>将从<code>stdout</code>中读取，如果它是期待的输出.</p>
<p>最简单的入门方法是创建自己的实现<code>Preprocessor</code> trait(例如在<code>lib.rs</code>)，然后创建一个 shell 二进制文件,将输入转换为正确的<code>Preprocessor</code>方法。为方便起见,有个<a href="https://github.com/rust-lang-nursery/mdBook/blob/master/examples/nop-preprocessor.rs">无操作预处理器:示例</a>在<code>examples/</code>目录,可以很容易地适应其他预处理器.</p>
<details>
<summary>Example 无操作预处理器</summary>
<pre><pre class="playground"><code class="language-rust edition2018">// nop-preprocessors.rs

extern crate clap;
extern crate mdbook;
extern crate serde_json;

use clap::{App, Arg, ArgMatches, SubCommand};
use mdbook::book::Book;
use mdbook::errors::Error;
use mdbook::preprocess::{CmdPreprocessor, Preprocessor, PreprocessorContext};
use std::io;
use std::process;
use nop_lib::Nop;

pub fn make_app() -&gt; App&lt;'static, 'static&gt; {
    App::new(&quot;nop-preprocessor&quot;)
        .about(&quot;A mdbook preprocessor which does precisely nothing&quot;)
        .subcommand(
            SubCommand::with_name(&quot;supports&quot;)
                .arg(Arg::with_name(&quot;renderer&quot;).required(true))
                .about(&quot;Check whether a renderer is supported by this preprocessor&quot;))
}

fn main() {
    let matches = make_app().get_matches();

    // Users will want to construct their own preprocessor here
    let preprocessor = Nop::new();

    if let Some(sub_args) = matches.subcommand_matches(&quot;supports&quot;) {
        handle_supports(&amp;preprocessor, sub_args);
    } else {
        if let Err(e) = handle_preprocessing(&amp;preprocessor) {
            eprintln!(&quot;{}&quot;, e);
            process::exit(1);
        }
    }
}

fn handle_preprocessing(pre: &amp;dyn Preprocessor) -&gt; Result&lt;(), Error&gt; {
    let (ctx, book) = CmdPreprocessor::parse_input(io::stdin())?;

    if ctx.mdbook_version != mdbook::MDBOOK_VERSION {
        // We should probably use the `semver` crate to check compatibility
        // here...
        eprintln!(
            &quot;Warning: The {} plugin was built against version {} of mdbook, \
             but we're being called from version {}&quot;,
            pre.name(),
            mdbook::MDBOOK_VERSION,
            ctx.mdbook_version
        );
    }

    let processed_book = pre.run(&amp;ctx, book)?;
    serde_json::to_writer(io::stdout(), &amp;processed_book)?;

    Ok(())
}

fn handle_supports(pre: &amp;dyn Preprocessor, sub_args: &amp;ArgMatches) -&gt; ! {
    let renderer = sub_args.value_of(&quot;renderer&quot;).expect(&quot;Required argument&quot;);
    let supported = pre.supports_renderer(&amp;renderer);

    // Signal whether the renderer is supported by exiting with 1 or 0.
    if supported {
        process::exit(0);
    } else {
        process::exit(1);
    }
}

/// The actual implementation of the `Nop` preprocessor. This would usually go
/// in your main `lib.rs` file.
mod nop_lib {
    use super::*;

    /// A no-op preprocessor.
    pub struct Nop;

    impl Nop {
        pub fn new() -&gt; Nop {
            Nop
        }
    }

    impl Preprocessor for Nop {
        fn name(&amp;self) -&gt; &amp;str {
            &quot;nop-preprocessor&quot;
        }

        fn run(
            &amp;self,
            ctx: &amp;PreprocessorContext,
            book: Book,
        ) -&gt; Result&lt;Book, Error&gt; {
            // In testing we want to tell the preprocessor to blow up by setting a
            // particular config value
            if let Some(nop_cfg) = ctx.config.get_preprocessor(self.name()) {
                if nop_cfg.contains_key(&quot;blow-up&quot;) {
                    return Err(&quot;Boom!!1!&quot;.into());
                }
            }

            // we *are* a no-op preprocessor after all
            Ok(book)
        }

        fn supports_renderer(&amp;self, renderer: &amp;str) -&gt; bool {
            renderer != &quot;not-supported&quot;
        }
    }
}

</code></pre></pre>
</details>
<h2 id="实现一个预处理器的提示"><a class="header" href="#实现一个预处理器的提示">实现一个预处理器的提示</a></h2>
<p>通过拉取<code>mdbook</code>，作为一个库,预处理器可以访问现有的基础架构来处理书籍.</p>
<p>例如,自定义预处理器可以使用<a href="https://docs.rs/mdbook/latest/mdbook/preprocess/trait.Preprocessor.html#method.parse_input"><code>CmdPreprocessor::parse_input()</code></a>函数， 用于反序列化写入<code>stdin</code>的 JSON。然后是<code>Book</code>的每一章可以通过<a href="https://docs.rs/mdbook/latest/mdbook/book/struct.Book.html#method.for_each_mut"><code>Book::for_each_mut()</code></a>成为可变权限，然后随着<code>serde_json</code>箱写到<code>stdout</code>.</p>
<p>章节可以直接访问(通过递归迭代章节)或通过便利方法<code>Book::for_each_mut()</code>.</p>
<p><code>chapter.content</code>只是一个恰好是 markdown 的字符串。虽然完全可以使用正则表达式或进行手动查找和替换，但您可能希望将输入处理为更加计算机友好的内容。该<a href="https://crates.io/crates/pulldown-cmark"><code>pulldown-cmark</code></a>crate 实现了一个基于事件，生产质量的 Markdown 解析器，而<a href="https://crates.io/crates/pulldown-cmark-to-cmark"><code>pulldown-cmark-to-cmark</code></a>允许您将事件转换回 markdown 文本.</p>
<p>以下代码块，显示了如何从 markdown 中删除所有强调(粗体),而不会意外地破坏文档.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn remove_emphasis(
    num_removed_items: &amp;mut usize,
    chapter: &amp;mut Chapter,
) -&gt; Result&lt;String&gt; {
    let mut buf = String::with_capacity(chapter.content.len());

    let events = Parser::new(&amp;chapter.content).filter(|e| {
        let should_keep = match *e {
            Event::Start(Tag::Emphasis)
            | Event::Start(Tag::Strong)
            | Event::End(Tag::Emphasis)
            | Event::End(Tag::Strong) =&gt; false,
            _ =&gt; true,
        };
        if !should_keep {
            *num_removed_items += 1;
        }
        should_keep
    });

    cmark(events, &amp;mut buf, None).map(|_| buf).map_err(|err| {
        Error::from(format!(&quot;Markdown serialization failed: {}&quot;, err))
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>对于其他的一切,看<a href="https://github.com/rust-lang-nursery/mdBook/blob/master/examples/nop-preprocessor.rs">完整的例子</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="备用后端"><a class="header" href="#备用后端">备用后端</a></h1>
<p>“后端“只是一个，<code>mdbook</code>在书籍渲染过程中调用的程序。该程序会拿到传递到<code>stdin</code>的书籍和配置信息的 JSON 表达式。一旦后端收到这些信息,就可以自由地做任何想做的事情.</p>
<p>GitHub 上已有几个备用后端,可以作为你实践，如何实现这一功能的粗略示例.</p>
<ul>
<li><a href="https://github.com/Michael-F-Bryan/mdbook-linkcheck">mdbook-linkcheck</a>- 用于验证书籍的简单程序，不包含任何损坏的链接</li>
<li><a href="https://github.com/Michael-F-Bryan/mdbook-epub">mdbook-epub</a>- EPUB 渲染器</li>
<li><a href="https://github.com/Michael-F-Bryan/mdbook-test">mdbook-test</a>- 一个使用<a href="https://github.com/budziq/rust-skeptic">rust-skeptic</a>运用书籍内容的程序，会验证一切编译且正确(类似于<code>rustdoc --test</code>)</li>
</ul>
<p>此页面将引导您，创建自己的单词计数程序的简单形式的备用后端。虽然它将用 Rust 编写,但没有理由不能用 Python 或 Ruby 之类，来完成它.</p>
<h2 id="目录"><a class="header" href="#目录">目录</a></h2>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<ul>
<li><a href="for_developers/backends.zh.html#%E8%AE%BE%E7%BD%AE%E5%A5%BD">设置好</a></li>
<li><a href="for_developers/backends.zh.html#%E6%A3%80%E6%9F%A5-book">检查 Book</a></li>
<li><a href="for_developers/backends.zh.html#%E5%90%AF%E7%94%A8%E5%90%A7%E6%88%91%E7%9A%84-backend">启用吧，我的 Backend</a></li>
<li><a href="for_developers/backends.zh.html#%E9%85%8D%E7%BD%AE">配置</a></li>
<li><a href="for_developers/backends.zh.html#%E8%BE%93%E5%87%BA%E5%92%8C%E4%BF%A1%E5%8F%B7%E6%95%85%E9%9A%9C">输出和信号故障</a></li>
<li><a href="for_developers/backends.zh.html#%E5%8C%85%E6%B6%B5%E5%8C%85%E6%B6%B5">包涵包涵</a></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<h2 id="设置好"><a class="header" href="#设置好">设置好</a></h2>
<p>首先,您需要创建一个新的二进制程序，并添加<code>mdbook</code>作为依赖.</p>
<pre><code class="language-shell">$ cargo new --bin mdbook-wordcount
$ cd mdbook-wordcount
$ cargo add mdbook
</code></pre>
<p>捋一捋，当我们的<code>mdbook-wordcount</code>插件被调用,<code>mdbook</code>将通过我们的插件的<code>stdin</code>，发送它<a href="https://docs.rs/mdbook/*/mdbook/renderer/struct.RenderContext.html"><code>RenderContext</code></a>的 JSON 版本。为方便起见,有一个<a href="https://docs.rs/mdbook/*/mdbook/renderer/struct.RenderContext.html#method.from_json"><code>RenderContext::from_json()</code></a>构造函数，加载一个<code>RenderContext</code>.</p>
<p>这是我们后端加载本书，所需的所有样板.</p>
<pre><pre class="playground"><code class="language-rust edition2018">// src/main.rs
extern crate mdbook;

use std::io;
use mdbook::renderer::RenderContext;

fn main() {
    let mut stdin = io::stdin();
    let ctx = RenderContext::from_json(&amp;mut stdin).unwrap();
}
</code></pre></pre>
<blockquote>
<p><strong>注意:</strong> <code>RenderContext</code>包含一个<code>version</code>字段。这使得后端在被调用时确定它们是否与<code>mdbook</code>版本兼容。这个<code>version</code>直接来自<code>mdbook</code>的<code>Cargo.toml</code>中的相应字段.</p>
</blockquote>
<p>建议后端使用<a href="https://crates.io/crates/semver"><code>semver</code></a>，如果可能存在兼容性问题,请检查此字段，并发出警告.</p>
<h2 id="检查-book"><a class="header" href="#检查-book">检查 Book</a></h2>
<p>现在我们的后端有一本书的副本,让我们计算每章中有多少单词!</p>
<p>因为<code>RenderContext</code>包含一个<a href="https://docs.rs/mdbook/*/mdbook/book/struct.Book.html"><code>Book</code></a>字段(<code>book</code>),和一个<code>Book</code>有<a href="https://docs.rs/mdbook/*/mdbook/book/struct.Book.html#method.iter"><code>Book::iter()</code></a>，用于迭代其<code>Book</code>中所有项的方法，这一步就和第一步一样简单.</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
    let mut stdin = io::stdin();
    let ctx = RenderContext::from_json(&amp;mut stdin).unwrap();

    for item in ctx.book.iter() {
        if let BookItem::Chapter(ref ch) = *item {
            let num_words = count_words(ch);
            println!(&quot;{}: {}&quot;, ch.name, num_words);
        }
    }
}

fn count_words(ch: &amp;Chapter) -&gt; usize {
    ch.content.split_whitespace().count()
}
</code></pre></pre>
<h2 id="启用吧我的-backend"><a class="header" href="#启用吧我的-backend">启用吧，我的 Backend</a></h2>
<p>现在我们的基本部分已经运行了，我们希望实际使用它。那首先,当然是安装程序.</p>
<pre><code>$ cargo install --path .
</code></pre>
<p>然后<code>cd</code>在特定的书目录中，若你想要数字计数，那更新它的<code>book.toml</code>文件.</p>
<pre><code class="language-diff">  [book]
  title = &quot;mdBook Documentation&quot;
  description = &quot;Create book from markdown files. Like Gitbook but implemented in Rust&quot;
  authors = [&quot;Mathieu David&quot;, &quot;Michael-F-Bryan&quot;]

+ [output.html]

+ [output.wordcount]
</code></pre>
<p>当<code>mdbook</code>将一本书加载到内存中时，它会尝试检查你的<code>book.toml</code>，并查找所有<code>output.*</code>表格来尝试找出要使用的后端。如果没有提供,它将回退到，使用默认的 HTML 渲染器.</p>
<p>值得注意的是，这表示如果你想添加自己的自定义后端,你还需要确保添加 HTML 后端,即使只是空表格。</p>
<p>现在你只需要像平常一样构建你的书,一切都应该<em>干得好</em>.</p>
<pre><code class="language-shell">$ mdbook build
...
2018-01-16 07:31:15 [INFO] (mdbook::renderer): Invoking the &quot;mdbook-wordcount&quot; renderer
mdBook: 126
Command Line Tool: 224
init: 283
build: 145
watch: 146
serve: 292
test: 139
Format: 30
SUMMARY.md: 259
Configuration: 784
Theme: 304
index.hbs: 447
Syntax highlighting: 314
MathJax Support: 153
Rust code specific features: 148
For Developers: 788
Alternative Backends: 710
Contributors: 85
</code></pre>
<p>我们之所以不需要指定我们<code>wordcount</code>后端的全名/路径，是因为<code>mdbook</code>会尽力的<em>推断</em>程序的名称，这些都是因为规范化，如下: 可执行文件<code>foo</code>后端通常被称为<code>mdbook-foo</code>,还有相关联的<code>[output.foo]</code>会进入<code>book.toml</code>。而要明确告诉<code>mdbook</code>要调用什么命令(可能需要命令行参数或是解释的脚本), 你可以使用<code>command</code>字段。</p>
<pre><code class="language-diff">  [book]
  title = &quot;mdBook Documentation&quot;
  description = &quot;Create book from markdown files. Like Gitbook but implemented in Rust&quot;
  authors = [&quot;Mathieu David&quot;, &quot;Michael-F-Bryan&quot;]

  [output.html]

  [output.wordcount]
+ command = &quot;python /path/to/wordcount.py&quot;
</code></pre>
<h2 id="配置"><a class="header" href="#配置">配置</a></h2>
<p>现在假设您不想计算特定章节上的单词数(可能是生成的文本/代码等)。要做到这样的规范方法，是通过常规<code>book.toml</code>配置文件，添加个别项到您的<code>[output.foo]</code>表格。</p>
<p><code>Config</code>可以粗略地视为嵌套的<code>hashmap</code>，它允许您调用类似的方法<code>get()</code>使用访问配置的内容，也带<code>get_deserialized()</code>这一方便方法,用于检索值，并自动反序列化为某种任意类型<code>T</code>.</p>
<p>为实现这一点,我们将创建自己的可序列化<code>WordcountConfig</code>结构将封装此后端的所有配置.</p>
<p>首先添加<code>serde</code>和<code>serde_derive</code>到你的<code>Cargo.toml</code>,</p>
<pre><code>$ cargo add serde serde_derive
</code></pre>
<p>然后你可以创建配置结构,</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate serde;
#[macro_use]
extern crate serde_derive;

...

#[derive(Debug, Default, Serialize, Deserialize)]
#[serde(default, rename_all = &quot;kebab-case&quot;)]
pub struct WordcountConfig {
  pub ignores: Vec&lt;String&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>现在我们只需要我们的<code>RenderContext</code>，反序列化成<code>WordcountConfig</code>，然后添加一个检查，以确保我们跳过忽略的章节.</p>
<pre><code class="language-diff">  fn main() {
      let mut stdin = io::stdin();
      let ctx = RenderContext::from_json(&amp;mut stdin).unwrap();
+     let cfg: WordcountConfig = ctx.config
+         .get_deserialized(&quot;output.wordcount&quot;)
+         .unwrap_or_default();

      for item in ctx.book.iter() {
          if let BookItem::Chapter(ref ch) = *item {
+             if cfg.ignores.contains(&amp;ch.name) {
+                 continue;
+             }
+
              let num_words = count_words(ch);
              println!(&quot;{}: {}&quot;, ch.name, num_words);
          }
      }
  }
</code></pre>
<h2 id="输出和信号故障"><a class="header" href="#输出和信号故障">输出和信号故障</a></h2>
<p>虽然在构建书籍时，将字数计数打印到终端是很好的，但将它们输出到某个文件也可能是个好主意。<code>mdbook</code>能告诉后端，它应该根据<a href="https://docs.rs/mdbook/*/mdbook/renderer/struct.RenderContext.html"><code>RenderContext</code></a>的<code>destination</code>字段，放置输出的位置，.</p>
<pre><code class="language-diff">+ use std::fs::{self, File};
+ use std::io::{self, Write};
- use std::io;
  use mdbook::renderer::RenderContext;
  use mdbook::book::{BookItem, Chapter};

  fn main() {
    ...

+     let _ = fs::create_dir_all(&amp;ctx.destination);
+     let mut f = File::create(ctx.destination.join(&quot;wordcounts.txt&quot;)).unwrap();
+
      for item in ctx.book.iter() {
          if let BookItem::Chapter(ref ch) = *item {
              ...

              let num_words = count_words(ch);
              println!(&quot;{}: {}&quot;, ch.name, num_words);
+             writeln!(f, &quot;{}: {}&quot;, ch.name, num_words).unwrap();
          }
      }
  }
</code></pre>
<blockquote>
<p><strong>注意:</strong> 无法保证目标目录存在或为空(<code>mdbook</code>可能会留下以前的内容让后端进行缓存)，因此创建它<code>fs::create_dir_all()</code>总不会错。</p>
<p>如果目的地目录已存在, 不要假设它就一定是空的。
要知道，后端是有上一结果缓存的, <code>mdbook</code> 或许会留下
旧的内容在里面。</p>
</blockquote>
<p>处理书籍时，总会出现错误(只需查看全部我们已经写过了的<code>unwrap()</code>),所以<code>mdbook</code>会渲染失败后，非零退出代码。</p>
<p>例如,如果我们想确保所有章节的单词，都有<em>偶数</em>数量, 而如果遇到奇数,则输出错误,那么你可以这样做:</p>
<pre><code class="language-diff">+ use std::process;
  ...

  fn main() {
      ...

      for item in ctx.book.iter() {
          if let BookItem::Chapter(ref ch) = *item {
              ...

              let num_words = count_words(ch);
              println!(&quot;{}: {}&quot;, ch.name, num_words);
              writeln!(f, &quot;{}: {}&quot;, ch.name, num_words).unwrap();

+             if cfg.deny_odds &amp;&amp; num_words % 2 == 1 {
+               eprintln!(&quot;{} has an odd number of words!&quot;, ch.name);
+               process::exit(1);
              }
          }
      }
  }

  #[derive(Debug, Default, Serialize, Deserialize)]
  #[serde(default, rename_all = &quot;kebab-case&quot;)]
  pub struct WordcountConfig {
      pub ignores: Vec&lt;String&gt;,
+     pub deny_odds: bool,
  }
</code></pre>
<p>现在,如果我们重新安装后端，并构建一本书,</p>
<pre><code class="language-shell">$ cargo install --path . --force
$ mdbook build /path/to/book
...
2018-01-16 21:21:39 [INFO] (mdbook::renderer): Invoking the &quot;wordcount&quot; renderer
mdBook: 126
Command Line Tool: 224
init: 283
init has an odd number of words!
2018-01-16 21:21:39 [ERROR] (mdbook::renderer): Renderer exited with non-zero return code.
2018-01-16 21:21:39 [ERROR] (mdbook::utils): Error: Rendering failed
2018-01-16 21:21:39 [ERROR] (mdbook::utils):    Caused By: The &quot;mdbook-wordcount&quot; renderer failed
</code></pre>
<p>您可能已经注意到,插件的子进程的输出会立即传递给用户。鼓励插件遵循“安静规则“，且仅在必要时生成输出(例如,生成错误或警告).</p>
<p>所有环境变量都传递到后端,允许您使用常用的<code>RUST_LOG</code>，控制日志记录详细程度.</p>
<h2 id="包涵包涵"><a class="header" href="#包涵包涵">包涵包涵</a></h2>
<p>虽然有点做作,但希望这个例子足以说明，如何创建一个<code>mdbook</code>备用后端。如果你觉得它遗漏了什么,请不要犹豫,创造一个问题的<a href="https://github.com/rust-lang-nursery/mdBook/issues">issue tracker</a>，让我们可以一起改进用户指南。</p>
<p>在本章开头提到的现有后端，应该是现实生活中如何完成后端的很好例子,所以请随意浏览源代码，或提出问题.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributors"><a class="header" href="#contributors">Contributors</a></h1>
<p>以下列出了帮助改进mdBook的贡献者。为他们欢呼!</p>
<ul>
<li><a href="https://github.com/mdinger">mdinger</a></li>
<li>Kevin (<a href="https://github.com/kbknapp">kbknapp</a>)</li>
<li>Steve Klabnik (<a href="https://github.com/steveklabnik">steveklabnik</a>)</li>
<li>Adam Solove (<a href="https://github.com/asolove">asolove</a>)</li>
<li>Wayne Nilsen (<a href="https://github.com/waynenilsen">waynenilsen</a>)</li>
<li><a href="https://github.com/funkill">funnkill</a></li>
<li>Fu Gangqiang (<a href="https://github.com/FuGangqiang">FuGangqiang</a>)</li>
<li><a href="https://github.com/Michael-F-Bryan">Michael-F-Bryan</a></li>
<li>Chris Spiegel (<a href="https://github.com/cspiegel">cspiegel</a>)</li>
<li><a href="https://github.com/projektir">projektir</a></li>
<li><a href="https://github.com/Phaiax">Phaiax</a></li>
<li>Matt Ickstadt (<a href="https://github.com/mattico">mattico</a>)</li>
<li>Weihang Lo (<a href="https://github.com/weihanglo">@weihanglo</a>)</li>
</ul>
<p>如果您觉得自己在此列表中遗漏了,请随意添加PR.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script type="text/javascript">
            window.playground_copyable = true;
        </script>

        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>

        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </body>
</html>
